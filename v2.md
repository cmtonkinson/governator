## Governator Project Phases:
1. Planning
2. Execution

### Planning
Governator provides a repeatable methodology for project planning.

Planning is opinionated by default, but totally configurable. Planning is treated mechanically by the system as a single
"task," where each step of planning acts like a unique "status." Therefore, every planning step is carried out
sequentially and the workers are managed (branches, worktrees, file structure) exactly the way they are for execution.

By default, planning consists of:
1. Architecture Baseline - discovers or invents the system architecture
2. Gap Analysis - identifies the deltas (along with unknowns) between current and desired state
3. Project Planning - creates the project roadmap (milestones, epics, features)
4. Task Planning - generates individual tasks for execution

Governator validates that each step of planning has been completed before moving on to the next step.

### Execution
Execution is the primary workhorse of Governator. Governator dispatches asynchronous agent workers to move a task
through the execution lifecycle (backlog, triaged, implemented, tested, reviewed, mergeable, merged). Each task lives in
a stable git branch/worktree through its lifecycle, no matter how many workers or state transitions it goes through.

Governator may (if configured) automatically dispatch multiple workers to execute tasks in parallel.

### Review
At any given point, a new command `review` may be run which, provided there are no tasks in progress, invokes a realtime
chat session between you and a new agent. The agent is instructed to ingest and analyze the current state of the project
so that you may ask questions, clarify, and drive refinements.

_Note: `review` will return failure if there are any active agents within the project._

`GOVERNATOR.md` remains the ultimate intent-carrier for all synthesis and verification within the system.

## Task Lifecycle
Task states:
- backlog
- triaged
- implemented
- tested
- reviewed
- mergeable
- merged

Tasks may have attributes, such as:
- assigned_role
- blocked (with reason)
- merge_conflict (detected)
- pid (process id, when an agent is working on a task)

The `status` command should report:
- Current phase (planning or execution)
- If planning,
  - An enumeration, in order, of all configured planning steps, and whether they are (complete, in progress, or open)
- If execution,
  - Number of backlog tasks
  - Number of merged tasks
  - Number of tasks in progress (all tasks which are not backlog or merged)
  - A table of tasks in progress with columns: id, state, pid, role, attrs, title
    - tasks sorted first by status (ascending), and then by id (ascending)
    - pid and role should be blank for tasks with no current working agent
    - attrs should be comma-joined (no spaces) and blank if there are no attributes; show only:
      - blocked
      - merge_conflict
      - (any future boolean flags in the same format)
    - title should be truncated such that the table fits on screen (if truncated, append "...")
    - status ordering is triaged (0), implemented (1), tested (2), reviewed (3), mergeable (4)

## Agent Concerns
CLI coding agents to be supported:
- Codex CLI
- Claude Code
- Gemini CLI

The first time a task is dispatched to a worker, a working branch and git worktree should be created for that task; this
branch and worktree should remain active and stable across the entire task lifecycle.

Each worker agent is spawned non-interactively (e.g. `codex exec`, `claude --print`, etc.), and must be spawned
asynchronously so that the Governator CLI does not block; this also becomes a crucial detail to allow parallelism.

## Open Questions:
- Is the system prompt for `review` one that puts the agent in charge (asking the operator clarifying questions to guide
  refinements), or is it one that expects the operator to probe and drive changes?
